% Created 2013-03-02 Sat 22:40
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\DeclareUnicodeCharacter{22EE}{\vdots}
\author{G. Jay Kerns}
\date{March 2, 2013}
\title{Introduction to \texttt{julia}}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Generated by Org mode 7.9.3f in Emacs 24.3.50.1.}}
\begin{document}

\maketitle
\tableofcontents

\vspace{0.25in}

This document is a \emph{brief} introduction to \texttt{julia}. It is a reworked
\emph{Brief Introduction to R} (which is an abbreviated Chapter 2 of \href{http:ipsur.org}{IPSUR})
which I usually distribute to students using R for the first time.
One of the reasons for this document is that I wanted to get better
acquainted with \texttt{julia} and thought it might make it easier for others
to get better acquainted with it, too. In what follows, we assume you
have at least a passing familiarity with Org-mode and Emacs
keybindings.

Please bear in mind that the discussion below is written as if a
person has launched \texttt{julia} with \texttt{M-x julia} and is sitting in front
of an ESS \texttt{julia} interactive session right now.  But that isn't
required.  In fact, one of the best things about Org-mode is that such
a thing in fact \textbf{is not} required, and a person can happily breeze
through an org file tapping \texttt{C-c C-c} as (s)he goes.  For the purpose
of this introductory document it doesn't matter which approach you
use; be warned, however, that some of the lower code blocks depend on
values from the upper code blocks and if you try to execute them out
of order then you will get an error.

\section[What you need to get started]{What you need to get started}
\label{sec-1}

You will need to install \href{http://julialang.org}{\texttt{julia}}, a recent version of \href{http://ess.r-project.org}{ESS}, and an
updated version of \href{http://orgmode.org}{Org-mode}.  Instructions for how to accomplish all
three tasks are detailed in \href{file://ob-julia-doc.org}{Org-mode and \texttt{julia}: an introduction}.
Please read that document first to get up to speed before continuing.

\textbf{Note:} several code blocks below have the header argument \texttt{:eval
  no-export} which means that the code block can be evaluated
  interactively in this session by \texttt{C-c C-c} with point in the code
  block but will \emph{not} be evaluated during export.  The reason is that
  those blocks have settings which conflict with my current setup yet
  are meant to be useful for others people.
\section[Getting started with julia]{Getting started with julia}
\label{sec-2}

\subsection[Communicating with julia]{Communicating with julia}
\label{sec-2-1}

There are three basic methods (provided by ESS) for communicating with
\texttt{julia}.

\begin{itemize}
\item \textbf{An Interactive session (julia>).} This is the most basic way to
complete simple, one-line commands. Do \texttt{M-x julia RET} during an
Emacs session and the Emacs/ESS \texttt{julia} mode will open in a buffer.
Type whatever command you like; \texttt{julia} will evaluate what is typed
there and output the results in the buffer.  This method is akin to
launching \texttt{julia} in a terminal.

\item \textbf{Source files.} For longer programs (called \emph{scripts}) there is too
much code to write all at once in an interactive session. Further,
sometimes we only wish to modify a small piece of the script and
before running it again in \texttt{julia}.

The way to do this is to open a dedicated \texttt{julia} script buffer with
the sequence \texttt{C-x C-f whatever.jl}, where \texttt{whatever.jl} is a \texttt{julia}
script which you've named whatever. Write the code in the buffer,
then when satisfied the user evaluates lines or regions according to
the following table. Then \texttt{julia} will evaluate the respective code
and give output in the interactive buffer.

\begin{center}
\begin{tabular}{ll}
\texttt{C-RET} & Send region or current line and step to next line of code.\\
\texttt{M-C-x} & Send region or function or paragraph.\\
\texttt{C-c C-c} & Send region or function or paragraph and step to next line.\\
\end{tabular}
\end{center}

\item \textbf{Script mode.} It is also possible to write a \texttt{julia} script (say, \texttt{myscript.jl} and evaluate the script from a terminal like this:

\begin{verbatim}
~$ julia myscript.jl
\end{verbatim}

Depending on what's in the script, \texttt{julia} can be instructed to do
all sorts of things.  See \texttt{julia -{}-help} for additional
options. (Note: you will need to add \texttt{julia} to your \texttt{PATH} or
otherwise execute \texttt{julia} from its location before proceeding with
this method.)
\end{itemize}
\subsection[\texttt{julia} is one fancy calculator]{\texttt{julia} is one fancy calculator}
\label{sec-2-2}

\texttt{julia} can do any arithmetic you can imagine. For example, in an
interactive session type \texttt{2 + 3} and observe

\begin{verbatim}
2 + 3
\end{verbatim}

\begin{verbatim}
5
\end{verbatim}

The \texttt{julia>} means that \texttt{julia} is waiting on your next command. Entry
numbers will be generated for each row, such as

\begin{verbatim}
[3:50]
\end{verbatim}

\begin{verbatim}
48-element Int32 Array:
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
  â‹®
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
\end{verbatim}

Notice that \texttt{julia} doesn't show the whole list of numbers, it elides
them with vertical ellipses \(\vdots\). Note also the \texttt{[3:50]}
notation, which generates all integers in sequence from 3 to 50. One
can also do things like

\begin{verbatim}
2 * 3 * 4 * 5  # multiply
sqrt(10)       # square root
pi             # pi
sqrt(-2)
\end{verbatim}

\begin{verbatim}
120
3.1622776601683795
3.141592653589793
ERROR: DomainError()
 in sqrt at math.jl:111
\end{verbatim}

Notice that a \texttt{DomainError()} was produced; we are not allowed to take
square roots of negative numbers. Also notice the number sign \texttt{\#},
which is used for comments. Everything typed on the same line after
the \texttt{\#} will be ignored by julia. There is no \texttt{julia} continuation
prompt. If you press \texttt{RET} before a statement is complete then empty
lines keep piling up until you finish the command.

Some other fuctions that will be of use are \texttt{abs()} for absolute
value, \texttt{log()} for the natural logarithm, \texttt{exp()} for the exponential
function, and \texttt{factorial()} for\ldots{} uh\ldots{} factorials.

Assignment is useful for storing values to be used later. Notice the
semicolon at the end of the first statement.  Without the semicolon,
\texttt{julia} would print the result of the assigment (namely, \texttt{5}).

\begin{verbatim}
y = 5;    # stores the value 5 in y
3 + y
\end{verbatim}

\begin{verbatim}

8
\end{verbatim}

There aren't other assignment operators (like \texttt{<-} in R).  For
variable names you can use letters (perhaps followed by) numbers,
and/or underscore "\_" characters. You cannot use mathematical
operators, you cannot use dots, and numbers can't go in front of
numbers (those are interpreted by \texttt{julia} as coefficients). Here are
some valid variable names: \texttt{x}, \texttt{x1}, \texttt{y32}, \texttt{z\_var}.

If you would like to enter the data 74,31,95,61,76,34,23,54,96 into
\texttt{julia}, you may create a data array with double brackets (the analogue
of the \texttt{c()} function in R).

\begin{verbatim}
fred = [74, 31, 95, 61, 76, 34, 23, 54, 96]
\end{verbatim}

\begin{verbatim}
9-element Int32 Array:
 74
 31
 95
 61
 76
 34
 23
 54
 96
\end{verbatim}

The array \texttt{fred} has 9 entries. We can access individual components
with bracket \texttt{[ ]} notation:

\begin{verbatim}
fred[3]
fred[2:4]
fred[[1, 3, 5, 8]]
\end{verbatim}

\begin{verbatim}
95
3-element Int32 Array:
 31
 95
 61
4-element Int32 Array:
 74
 95
 76
 54
\end{verbatim}

Notice we needed double brackets for the third example. If you would
like to empty the array \texttt{fred}, you can do it by typing \texttt{fred = []}.

Data arrays in \texttt{julia} have type. There are all sorts of integer types
(\texttt{Int8}, \texttt{uInt8}, \texttt{Int32}, \ldots{}), strings (\texttt{ASCIIString}), logical
(\texttt{Bool}), unicode characters (\texttt{Char}), then there are floating-point
types (\texttt{Float16}, \texttt{Float32}), even complex numbers like \texttt{1 + 2im} and
even rational numbers like \texttt{3//4}, not to mention \texttt{Inf}, \texttt{-Inf}, and
\texttt{NaN} (which stands for \emph{not a number}). If you ever want to know what
it is you're dealing with you can find out with the \texttt{typeof} function.

\begin{verbatim}
simpsons = ["Homer", "Marge", "Bart", "Lisa", "Maggie"];
typeof(simpsons)
\end{verbatim}

\begin{verbatim}

Array{ASCIIString,1}
\end{verbatim}

Here is an example of a logical vector:

\begin{verbatim}
x = 5;
x >= 6
\end{verbatim}

\begin{verbatim}

false
\end{verbatim}

Notice the \verb~>=~ symbol which stands for "greater than or equal to".
Many functions in \texttt{julia} are vectorized. Once we have stored a data
vector then we can evaluate functions on it.

\begin{verbatim}
sum(fred)
length(fred)
sum(fred)/length(fred)
mean(fred)   # sample mean, should be same answer
\end{verbatim}

\begin{verbatim}
544
9
60.44444444444444
60.44444444444444
\end{verbatim}

Other popular functions for vectors are \texttt{min()}, \texttt{max()}, \texttt{sort()},
and \texttt{cumsum()}.

Arithmetic in \texttt{julia} is usually done element-wise, and the operands
(usually) must be of conformable dimensions.

\begin{verbatim}
mary = [4, 5, 3, 6, 4, 6, 7, 3, 1];
fred + mary
fred - mean(mary)
\end{verbatim}

\begin{verbatim}
9-element Int32 Array:
 78
 36
 98
 67
 80
 40
 30
 57
 97
9-element Float64 Array:
 69.6667
 26.6667
 90.6667
 56.6667
 71.6667
 29.6667
 18.6667
 49.6667
 91.6667
\end{verbatim}

The operations \texttt{+} and \texttt{-} are performed element-wise. Notice in the
last vector that \texttt{mean(fred)} was subtracted from each entry in
turn. This is also known as data recycling. Other popular vectorizing
functions are \texttt{sin()}, \texttt{cos()}, \texttt{exp()}, \texttt{log()}, and \texttt{sqrt()}.

An operation which is \emph{not} performed elementwise is array multiplication, \texttt{*}.  If were were to try \texttt{fred*mary} then we would get an error:

\begin{verbatim}
ERROR: no method *(Array{Int32,1},Array{Int32,1})
\end{verbatim}

The reason for the error is that \texttt{julia} is trying to do matrix multiplication on two \texttt{9x1} arrays which, we know from Linear Algebra, is not allowed. Instead, we can accomplish element-wise multiplication with the following:

\begin{verbatim}
fred.*mary
\end{verbatim}

\begin{verbatim}
9-element Int32 Array:
 296
 155
 285
 366
 304
 204
 161
 162
  96
\end{verbatim}

Notice the dot before the multiplication.  A similar trick works for
elementwise division.  By the way, with two \texttt{9x1} arrays it is legal
to compute the dot product like this:

\begin{verbatim}
fred'*mary
\end{verbatim}

\begin{verbatim}
1-element Int32 Array:
 2029
\end{verbatim}

where notice we have transposed \texttt{fred} and done ordinary matrix
multiplication with \texttt{fred'*mary}.
\subsection[Getting Help]{Getting Help}
\label{sec-2-3}

When you get in the thick of \texttt{julia} you will soon find yourself
looking for help. The help resources for \texttt{julia} are not (yet) as
extensive as those for some other languages that have been around for
a while (such as R).  \texttt{julia} is new and many of the help topics
haven't been written yet.  Nevertheless, sometimes a person is lucky
and you can get help on a function when it's available with the
\texttt{help()} function.

\begin{verbatim}
help("factorial")
\end{verbatim}

\begin{verbatim}
Base.factorial(n)

   Factorial of n

Base.factorial(n, k)

   Compute "factorial(n)/factorial(k)"
\end{verbatim}

In addition to this, you can type \texttt{help()} which gives an extended
list of help topics.  For instance, I find myself doing
\texttt{help("Statistics")} a lot.
\section[Other tips]{Other tips}
\label{sec-3}

It is unnecessary to retype commands repeatedly, since Emacs/ESS
remembers what you have entered at the \texttt{julia>} prompt. To navigate
through previous commands put point at the lowest command line and
do either \texttt{M-p} or \texttt{M-n}.

\subsection[Other resources]{Other resources}
\label{sec-3-1}

\begin{itemize}
\item Check out the official \texttt{julia} manual \href{http://docs.julialang.org/en/latest/manual/}{here}.
\item The \emph{Standard Library} (a different type of manual) is \href{http://docs.julialang.org/en/latest/stdlib/}{here}.
\item There is a vibrant and growing \texttt{julia} community whose gateway is \href{http://julialang.org/community/}{here}.
\item There is a large and growing list of contributed packages \href{http://docs.julialang.org/en/latest/packages/packagelist/}{here}.
\end{itemize}
\section[Plotting with Winston]{Plotting with Winston}
\label{sec-4}

There's a pretty well fleshed out plotting example in the Graphics
section of \href{file://ob-julia-doc.org}{Org-mode and \texttt{julia}: an introduction}.  Check it out.
\section[Fitting (generalized) linear models]{Fitting (generalized) linear models}
\label{sec-5}

Douglas Bates (of \href{http://www.springer.com/statistics/statistical+theory+and+methods/book/978-1-4419-0317-4}{Mixed Effects Models in S and S-PLUS} fame) has been
putting together a \texttt{julia} package called GLM which already supports
fitting generalized linear models to datasets.  This, together with
the RDatasets package means there is already a bunch of stuff to keep
a person busy.  Below is a modified example from the Multiple
Regression chapter of IPSUR, translated to \texttt{julia} speak.

First, we start \texttt{using} the packages we'll need.

\begin{verbatim}
using RDatasets, DataFrames, Distributions, GLM
\end{verbatim}

Next we load the \texttt{trees} data frame from the RDatasets package (via
the DataFrames package) and fit a linear model to the data.

\begin{verbatim}
trees = data("datasets", "trees")
treeslm = lm(:(Girth ~ Height + Volume), trees)
\end{verbatim}

There is a \emph{ton} of output from both the above commands which we omit
here for the sake of brevity.  Most of it, though, is similar to to
output we might see in an R session.  We can extract the model
coefficients with the \texttt{coef} function:

\begin{verbatim}
coef(treeslm)
\end{verbatim}

\begin{verbatim}
3-element Float64 Array:
 10.8164   
 -0.0454835
  0.19518
\end{verbatim}

and we can finish by looking at a summary table similar to something
like \texttt{summary(treeslm)} in R.

\begin{verbatim}
coeftable(treeslm)
\end{verbatim}

\begin{verbatim}
3x4 DataFrame:
          Estimate Std.Error  t value   Pr(>|t|)
[1,]       10.8164    1.9732  5.48165 7.44691e-6
[2,]    -0.0454835 0.0282621 -1.60935   0.118759
[3,]       0.19518 0.0109553  17.8161 8.2233e-17
\end{verbatim}
% Generated by Org mode 7.9.3f in Emacs 24.3.50.1.
\end{document}